name: Deploy Production Final

on:
  workflow_dispatch: 

jobs:
  deploy-prod:
    runs-on: ubuntu-latest
    name: Deploy to Cloudflare (Prod)
    env:
      # Pin tool versions to avoid upstream updates breaking CI
      WORKER_BUILD_VERSION: "0.7.1"
      WRANGLER_VERSION: "4.54.0"
      # Web Vault frontend (bw_web_builds) version tag (default pinned; override via GitHub Actions Variables)
      # - Set repository variable BW_WEB_VERSION_DEV (e.g. v2025.12.0) to override
      # - Set to "latest" to follow the latest bw_web_builds release
      BW_WEB_VERSION: ${{ vars.BW_WEB_VERSION || 'v2025.12.0' }}

      # Required for wrangler
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
    steps:
      - uses: actions/checkout@v4

      - name: Download Frontend (Bitwarden Web Vault)
        run: |
          set -euo pipefail
          TAG="${BW_WEB_VERSION}"
          if [ "${TAG}" = "latest" ]; then
            TAG="$(curl -s https://api.github.com/repos/dani-garcia/bw_web_builds/releases/latest | jq -r .tag_name)"
          fi

          echo "üì¶ Downloading frontend version: ${TAG}"

          # Download the web vault release
          wget -q "https://github.com/dani-garcia/bw_web_builds/releases/download/${TAG}/bw_web_${TAG}.tar.gz"

          # Extract to public/web-vault
          tar -xzf "bw_web_${TAG}.tar.gz" -C public/

          # bw_web_builds extracts into a web-vault folder (expected)
          if [ ! -d "public/web-vault" ]; then
            echo "‚ùå Expected ./public/web-vault after extracting bw_web_builds" >&2
            ls -la public/ | head -50 || true
            exit 1
          fi

          # Remove large source maps to satisfy Cloudflare static asset per-file limits
          find public/web-vault -type f -name '*.map' -delete

          # Cleanup
          rm -f "bw_web_${TAG}.tar.gz"

          echo "‚úÖ Frontend files extracted to ./public/web-vault"
          ls -la public/web-vault/ | head -20

      - name: Apply web vault overrides (vaultwarden.css)
        run: |
          bash scripts/apply-web-vault-overrides.sh public/web-vault

      - name: Patch wrangler.toml
        run: |
          # 1. Fix typo: d1_namespaces ‚Üí d1_databases
          sed -i 's/[[d1_namespaces]]/[[d1_databases]]/g' wrangler.toml
          
          # 2. Ganti database_name "vault1" ‚Üí secret (production only, before [env.dev])
          sed -i '0,/^\[env/{s/database_name = "vault1"/database_name = "${{ secrets.D1_DATABASE_NAME }}"/}' wrangler.toml
          
          # 3. Ganti D1_DATABASE_ID placeholder (production only, before [env.dev)
          sed -i '0,/^\[env/{s/${D1_DATABASE_ID}/${{ secrets.D1_DATABASE_ID }}/g}' wrangler.toml
          
          # 4. Inject KV namespace ID (production only, before [env.dev])
          sed -i '0,/^\[env/{{ /binding = "ATTACHMENTS_KV"/a\    id = "${{ secrets.ATTACHMENTS_KV_ID }}"
          }' wrangler.toml
          
          echo "‚úÖ wrangler.toml patched: Name=${{ secrets.D1_DATABASE_NAME }}, ID=Injected, Binding=vault1"
      - name: Validate wrangler.toml changes
        run: |
          echo "üîç Validating production D1 config..."
          grep -A 5 "^[[d1_databases]]" wrangler.toml | head -6
          
          echo ""
          echo "üîç Validating production KV config..."
          grep -A 2 "^[[kv_namespaces]]" wrangler.toml | head -3
          
          echo ""
          echo "üîç Checking dev config is unchanged..."
          grep -A 5 "^\[\[env.dev.d1_databases\]\]" wrangler.toml | head -6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install worker-build
        run: |
          set -euo pipefail
          if command -v worker-build &> /dev/null; then
              echo "worker-build already installed: $(worker-build --version || true)"
          fi
          cargo install --locked -q worker-build --version "${WORKER_BUILD_VERSION}"

      - name: Apply D1 database migrations
        run: |
          set -euo pipefail  # Ensure pipe returns first non-zero exit code
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"
          DB_NAME="${{ secrets.D1_DATABASE_NAME }}"

          # Apply migrations with retry loop to handle legacy ensure_schema columns
          MAX_RETRIES=10
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "üîÑ Attempting to apply migrations (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."

            if $WRANGLER d1 migrations apply "${DB_NAME}" --remote 2>&1 | tee migration_output.txt; then
              echo "‚úÖ All migrations applied successfully"
              exit 0
            fi

            # Check if failure is due to duplicate column (from legacy ensure_schema)
            if grep -q "duplicate column name" migration_output.txt; then
              # Extract the migration name that failed
              # Format: "Migration 0001_add_password_salt.sql failed with the following errors:"
              FAILED_MIGRATION=$(grep -oP "Migration \K[0-9]+_[a-zA-Z0-9_]+\.sql(?= failed)" migration_output.txt)
              if [ -z "$FAILED_MIGRATION" ]; then
                echo "‚ùå Detected duplicate column error, but could not identify the migration filename from output."
                cat migration_output.txt
                exit 1
              fi

              echo "‚ö†Ô∏è Migration '$FAILED_MIGRATION' failed: column already exists"
              echo "üìù Marking migration as applied..."

              # Initialize d1_migrations table and mark this migration as applied
              $WRANGLER d1 execute "${DB_NAME}" --remote --command "
                CREATE TABLE IF NOT EXISTS d1_migrations (
                  id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT UNIQUE NOT NULL,
                  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
                );
                INSERT OR IGNORE INTO d1_migrations (name) VALUES ('$FAILED_MIGRATION');
              "

              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "üîÅ Retrying remaining migrations..."
            else
              echo "‚ùå Migration failed with unexpected error:"
              cat migration_output.txt
              exit 1
            fi
          done

          echo "‚ùå Max retries ($MAX_RETRIES) exceeded"
          exit 1

      - name: Bootstrap D1 schema when database is empty
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"
          DB_NAME="${{ secrets.D1_DATABASE_NAME }}"

          # Capture raw wrangler output so jq parse errors don't hide the real failure.
          set +e
          D1_OUT="$($WRANGLER d1 execute "${DB_NAME}" --remote --command \
            "SELECT COUNT(*) AS cnt FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '_cf_%' AND name NOT IN ('d1_migrations');" \
            --json 2>&1)"
          D1_STATUS=$?
          set -e
          if [ $D1_STATUS -ne 0 ]; then
            echo "‚ùå wrangler d1 execute failed (exit=$D1_STATUS). Raw output:"
            echo "$D1_OUT"
            exit $D1_STATUS
          fi

          TABLE_COUNT="$(printf '%s' "$D1_OUT" | jq -er 'if type=="array" and (length>0) and (.[0].results|type=="array") and (.[0].results|length>0) then (.[0].results[0].cnt // 0) else error("unexpected JSON shape") end' 2>/dev/null || true)"
          if [ -z "${TABLE_COUNT}" ]; then
            echo "‚ùå Unexpected JSON from wrangler (cannot extract table count). Raw output:"
            echo "$D1_OUT"
            exit 1
          fi

          echo "Existing app table count: ${TABLE_COUNT}"
          if [ "${TABLE_COUNT}" = "0" ]; then
            echo "üÜï Empty D1 database detected; applying sql/schema.sql..."
            $WRANGLER d1 execute "${DB_NAME}" --remote --file sql/schema.sql

            echo "üìù Marking existing migrations as applied (schema.sql already includes them)"
            BOOTSTRAP_SQL="$(mktemp)"
            cat >"${BOOTSTRAP_SQL}" <<'SQL'
          CREATE TABLE IF NOT EXISTS d1_migrations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE NOT NULL,
            applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
          );
            SQL
              shopt -s nullglob
              for f in migrations/*.sql; do
                echo "INSERT OR IGNORE INTO d1_migrations (name) VALUES ('$(basename "${f}")');" >>"${BOOTSTRAP_SQL}"
              done

              $WRANGLER d1 execute "${DB_NAME}" --remote --file "${BOOTSTRAP_SQL}"
              rm -f "${BOOTSTRAP_SQL}"
            else
              echo "‚è≠Ô∏è D1 already has tables; skipping base schema bootstrap"
            fi

      - name: Deploy to Cloudflare
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: ${{ env.WRANGLER_VERSION }} 
          command: deploy
